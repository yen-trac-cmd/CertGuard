# mitm_revocation_v3.py
# Code (almost) entirely generated by ChatGPT.
# mitmproxy 12.1.2 compatible revocation checker
# - OCSP first, CRL fallback
# - Verifies OCSP response signature (responder cert or issuer)
# - Caches OCSP/CRL results with TTL (uses OCSP NextUpdate / CRL next_update if present)
# Dependencies: pip install cryptography requests

from mitmproxy import http, ctx
from cryptography import x509
from cryptography.x509 import ocsp
from cryptography.x509.oid import ExtensionOID, ExtendedKeyUsageOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding
import requests
import time
import typing
import binascii

# Policy: "fail_open" or "fail_closed"
POLICY = "fail_open"

# Cache: key -> (expiry_ts, parsed_result dict)
_CACHE: typing.Dict[str, typing.Tuple[float, dict]] = {}
DEFAULT_MAX_TTL = 24 * 3600  # 24 hours max
DEFAULT_MIN_TTL = 30         # 30 seconds min


def cache_get(key: str) -> typing.Optional[dict]:
    ent = _CACHE.get(key)
    if not ent:
        return None
    expiry, payload = ent
    if time.time() > expiry:
        del _CACHE[key]
        return None
    return payload


def cache_set(key: str, payload: dict, ttl: int):
    ttl = max(DEFAULT_MIN_TTL, min(DEFAULT_MAX_TTL, int(ttl)))
    _CACHE[key] = (time.time() + ttl, payload)
    ctx.log.debug(f"[revoc] cache_set {key} ttl={ttl}s")


def fetch_url(url: str, timeout: float = 6.0) -> typing.Optional[bytes]:
    try:
        r = requests.get(url, timeout=timeout)
        r.raise_for_status()
        return r.content
    except Exception as e:
        ctx.log.debug(f"[revoc] fetch_url {url} failed: {e}")
        return None


def post_ocsp(url: str, body: bytes, timeout: float = 6.0) -> typing.Optional[bytes]:
    try:
        headers = {"Content-Type": "application/ocsp-request"}
        r = requests.post(url, data=body, headers=headers, timeout=timeout)
        r.raise_for_status()
        return r.content
    except Exception as e:
        ctx.log.debug(f"[revoc] post_ocsp {url} failed: {e}")
        return None


def get_ocsp_urls(cert: x509.Certificate) -> typing.List[str]:
    try:
        aia = cert.extensions.get_extension_for_oid(ExtensionOID.AUTHORITY_INFORMATION_ACCESS).value
        out = []
        for desc in aia:
            if desc.access_method == x509.AuthorityInformationAccessOID.OCSP:
                out.append(desc.access_location.value)
        return out
    except Exception:
        return []


def get_crl_urls(cert: x509.Certificate) -> typing.List[str]:
    try:
        ext = cert.extensions.get_extension_for_oid(ExtensionOID.CRL_DISTRIBUTION_POINTS).value
        out = []
        for dp in ext:
            if dp.full_name:
                for name in dp.full_name:
                    if isinstance(name, x509.UniformResourceIdentifier):
                        out.append(name.value)
        return out
    except Exception:
        return []


def build_ocsp_request(leaf: x509.Certificate, issuer: x509.Certificate) -> bytes:
    builder = ocsp.OCSPRequestBuilder()
    builder = builder.add_certificate(leaf, issuer, hashes.SHA1())
    req = builder.build()
    return req.public_bytes(serialization.Encoding.DER)


def parse_and_verify_ocsp_response(resp_data: bytes, issuer: x509.Certificate, leaf: x509.Certificate) -> typing.Tuple[str, int]:
    """
    Parse OCSP response and verify signature.
    Returns (status, ttl_seconds) where status is "good"/"revoked"/"unknown".
    On error returns ("unknown", default_ttl).
    """
    try:
        ocsp_resp = ocsp.load_der_ocsp_response(resp_data)
    except Exception:
        # Try PEM variant
        try:
            pem = resp_data.decode(errors="ignore")
            # cryptography expects DER for ocsp; we could try to strip PEM headers, but most servers return DER for POST
            ctx.log.debug("[revoc] OCSP parse failed (not DER).")
            return "unknown", DEFAULT_MIN_TTL
        except Exception:
            return "unknown", DEFAULT_MIN_TTL

    # If response status not successful, unknown
    if ocsp_resp.response_status != ocsp.OCSPResponseStatus.SUCCESSFUL:
        ctx.log.debug(f"[revoc] OCSP response status not successful: {ocsp_resp.response_status}")
        return "unknown", DEFAULT_MIN_TTL

    # Verify signature: try responder certs included in response first
    verified = False
    verification_errors = []
    try:
        tbs = ocsp_resp.tbs_response_bytes
        sig = ocsp_resp.signature
        sig_hash_alg = ocsp_resp.signature_hash_algorithm  # HashAlgorithm instance

        # Try certificates embedded in OCSP response
        responder_certs = getattr(ocsp_resp, "certificates", None)
        if responder_certs:
            for rc in responder_certs:
                try:
                    pub = rc.public_key()
                    pub.verify(sig, tbs, padding.PKCS1v15(), sig_hash_alg)
                    # additional check: responder cert should have OCSP signing EKU OR be the issuer
                    ok = False
                    try:
                        eku = rc.extensions.get_extension_for_oid(ExtensionOID.EXTENDED_KEY_USAGE).value
                        for oid in eku:
                            if oid == ExtendedKeyUsageOID.OCSP_SIGNING:
                                ok = True
                                break
                    except Exception:
                        # no EKU extension, accept if rc == issuer
                        pass
                    if not ok:
                        # check if responder cert equals issuer (rare)
                        if rc.subject == issuer.subject and rc.public_key().public_bytes(
                            serialization.Encoding.DER, serialization.PublicFormat.SubjectPublicKeyInfo
                        ) == issuer.public_key().public_bytes(
                            serialization.Encoding.DER, serialization.PublicFormat.SubjectPublicKeyInfo
                        ):
                            ok = True
                    if not ok:
                        raise ValueError("responder cert not valid OCSP signer (no OCSP EKU and not issuer)")
                    verified = True
                    ctx.log.debug("[revoc] OCSP signature verified by responder cert included in response")
                    break
                except Exception as e:
                    verification_errors.append(str(e))
        # If not verified yet, try issuer cert
        if not verified and issuer is not None:
            try:
                pub = issuer.public_key()
                pub.verify(sig, tbs, padding.PKCS1v15(), sig_hash_alg)
                verified = True
                ctx.log.debug("[revoc] OCSP signature verified by issuer cert")
            except Exception as e:
                verification_errors.append(f"issuer verify failed: {e}")
    except Exception as e:
        ctx.log.debug(f"[revoc] OCSP signature verification setup failed: {e}")
        return "unknown", DEFAULT_MIN_TTL

    if not verified:
        ctx.log.debug(f"[revoc] OCSP signature verification failed: {verification_errors}")
        return "unknown", DEFAULT_MIN_TTL

    # Now read the single response status for the certificate matching leaf
    try:
        cert_status = ocsp_resp.certificate_status
        if cert_status == ocsp.OCSPCertStatus.GOOD:
            status = "good"
        elif cert_status == ocsp.OCSPCertStatus.REVOKED:
            status = "revoked"
        else:
            status = "unknown"
    except Exception:
        status = "unknown"

    # Determine TTL from next_update or this_update
    ttl = DEFAULT_MIN_TTL
    try:
        # ocsp_resp.next_update can be None
        nu = ocsp_resp.next_update_utc
        if nu is not None:
            # seconds until next_update
            ttl = max(DEFAULT_MIN_TTL, int((nu - time.time()).total_seconds()) if hasattr(nu, 'timestamp') else DEFAULT_MIN_TTL)
        else:
            # fallback to this_update + some small TTL
            tu = ocsp_resp.this_update_utc
            if tu is not None:
                # no next_update; set small TTL (e.g., 5 minutes)
                ttl = 300
    except Exception:
        ttl = DEFAULT_MIN_TTL

    # Bound TTL sensibly
    ttl = max(DEFAULT_MIN_TTL, min(DEFAULT_MAX_TTL, ttl))
    return status, ttl


def parse_crl_and_ttl(crl_data: bytes) -> typing.Tuple[typing.Optional[x509.CertificateRevocationList], int]:
    try:
        try:
            crl = x509.load_der_x509_crl(crl_data)
        except Exception:
            crl = x509.load_pem_x509_crl(crl_data)
        # use next_update if present
        nu = crl.next_update_utc
        if nu is not None:
            # compute TTL seconds
            ttl = int((nu - datetime_now()).total_seconds())
            ttl = max(DEFAULT_MIN_TTL, min(DEFAULT_MAX_TTL, ttl))
        else:
            ttl = DEFAULT_MIN_TTL
        return crl, ttl
    except Exception as e:
        ctx.log.debug(f"[revoc] parse_crl_and_ttl failed: {e}")
        return None, DEFAULT_MIN_TTL


def datetime_now():
    # wrapper to avoid importing datetime all over; return timezone-aware or naive consistent object
    import datetime
    return datetime.datetime.utcnow()


def check_crl_for_revocation(leaf: x509.Certificate, crl_data: bytes) -> typing.Tuple[bool, int]:
    """
    Returns (is_revoked, ttl_seconds)
    """
    try:
        try:
            crl = x509.load_der_x509_crl(crl_data)
        except Exception:
            crl = x509.load_pem_x509_crl(crl_data)
        # iterate revocations
        for r in crl:
            if r.serial_number == leaf.serial_number:
                return True, max(DEFAULT_MIN_TTL, min(DEFAULT_MAX_TTL, int((crl.next_update_utc - datetime_now()).total_seconds()) if crl.next_update_utc else DEFAULT_MIN_TTL))
        # no revocation
        ttl = DEFAULT_MIN_TTL
        if crl.next_update is not None:
            try:
                ttl = int((crl.next_update_utc - datetime_now()).total_seconds())
            except Exception:
                ttl = DEFAULT_MIN_TTL
        ttl = max(DEFAULT_MIN_TTL, min(DEFAULT_MAX_TTL, ttl))
        return False, ttl
    except Exception as e:
        ctx.log.debug(f"[revoc] CRL parse failed: {e}")
        return False, DEFAULT_MIN_TTL


class RevocationCheckerV3:
    def __init__(self):
        self.policy = POLICY
        ctx.log.info(f"[revoc] RevocationCheckerV3 initialized (policy={self.policy})")

    def _parse_cert_flexible(self, cert_obj) -> typing.Optional[x509.Certificate]:
        if cert_obj is None:
            return None
        if hasattr(cert_obj, "to_pem"):
            try:
                pem = cert_obj.to_pem()
                return x509.load_pem_x509_certificate(pem)
            except Exception as e:
                ctx.log.debug(f"[revoc] to_pem parse failed: {e}")
        if isinstance(cert_obj, (bytes, bytearray)):
            b = bytes(cert_obj)
            try:
                return x509.load_der_x509_certificate(b)
            except Exception:
                try:
                    return x509.load_pem_x509_certificate(b)
                except Exception as e:
                    ctx.log.debug(f"[revoc] bytes parse failed: {e}")
                    return None
        if isinstance(cert_obj, str):
            try:
                return x509.load_pem_x509_certificate(cert_obj.encode())
            except Exception as e:
                ctx.log.debug(f"[revoc] str parse failed: {e}")
                return None
        ctx.log.debug(f"[revoc] Unknown cert object type: {type(cert_obj)}")
        return None

    def _extract_certs_from_server_conn(self, sc) -> typing.Tuple[typing.Optional[object], typing.Optional[object]]:
        server = None
        issuer = None
        if hasattr(sc, "cert_chain") and sc.cert_chain:
            try:
                server = sc.cert_chain[0]
                if len(sc.cert_chain) > 1:
                    issuer = sc.cert_chain[1]
                return server, issuer
            except Exception as e:
                ctx.log.debug(f"[revoc] cert_chain read failed: {e}")
        if hasattr(sc, "cert") and sc.cert:
            server = sc.cert
            return server, issuer
        try:
            sock = getattr(sc, "sock", None)
            if sock is not None:
                try:
                    der = sock.getpeercert(binary_form=True)
                    if der:
                        return der, issuer
                except Exception as e:
                    ctx.log.debug(f"[revoc] sock.getpeercert failed: {e}")
        except Exception:
            pass
        return None, None

    def evaluate_revocation(self, server_cert_obj, issuer_cert_obj=None) -> str:
        leaf = self._parse_cert_flexible(server_cert_obj)
        if not leaf:
            ctx.log.debug("[revoc] unable to parse leaf cert")
            return "unknown"
        issuer = None
        if issuer_cert_obj is not None:
            issuer = self._parse_cert_flexible(issuer_cert_obj)

        # OCSP attempt
        ocsp_urls = get_ocsp_urls(leaf)
        if ocsp_urls and issuer is not None:
            # build request
            ocsp_req = build_ocsp_request(leaf, issuer)
            # key for cache includes body digest + URL
            for url in ocsp_urls:
                key = f"ocsp:{url}:{binascii.hexlify(hashes.SHA1().copy().update(ocsp_req) or b'').decode()}"
                # cannot compute digest that way; use simpler key with length - it's ok because kc is temporary
                key = f"ocsp:{url}:len{len(ocsp_req)}"
                cached = cache_get(key)
                if cached:
                    ctx.log.debug(f"[revoc] OCSP cache hit {url}")
                    status = cached.get("status", "unknown")
                    return status
                ocsp_resp_data = post_ocsp(url, ocsp_req)
                if not ocsp_resp_data:
                    continue
                status, ttl = parse_and_verify_ocsp_response(ocsp_resp_data, issuer, leaf)
                cache_set(key, {"status": status}, ttl)
                if status in ("good", "revoked"):
                    return status
            # OCSP attempts exhausted
        else:
            ctx.log.debug("[revoc] no OCSP urls or no issuer cert; skipping OCSP")

        # CRL fallback
        crl_urls = get_crl_urls(leaf)
        if crl_urls:
            for url in crl_urls:
                key = f"crl:{url}"
                cached = cache_get(key)
                if cached:
                    ctx.log.debug(f"[revoc] CRL cache hit {url}")
                    if cached.get("revoked"):
                        return "revoked"
                    else:
                        continue
                data = fetch_url(url)
                if not data:
                    continue
                revoked, ttl = check_crl_for_revocation(leaf, data)
                cache_set(key, {"revoked": revoked}, ttl)
                if revoked:
                    return "revoked"
                else:
                    return "good"
            # finished CRL checks
        else:
            ctx.log.debug("[revoc] no CRL distribution points")

        return "unknown"

    def request(self, flow: http.HTTPFlow):
        if getattr(flow, "_rev_checked_v3", False):
            return
        flow._rev_checked_v3 = True

        sc = flow.server_conn
        if not sc:
            return
        if not getattr(sc, "tls_established", False):
            return

        server_obj, issuer_obj = self._extract_certs_from_server_conn(sc)
        if not server_obj:
            ctx.log.warn("[revoc] could not extract upstream certificate from server_conn")
            if self.policy == "fail_closed":
                self._block_flow(flow, "unable to extract upstream certificate")
            else:
                ctx.log.debug("[revoc] policy fail_open - allowing flow despite missing cert")
            return

        status = self.evaluate_revocation(server_obj, issuer_obj)
        ctx.log.info(f"[revoc] revocation status: {status} for {getattr(sc, 'address', '(unknown)')}")
        if status == "revoked":
            self._block_flow(flow, "upstream certificate revoked")
        elif status == "unknown":
            if self.policy == "fail_closed":
                self._block_flow(flow, "revocation unknown (policy fail_closed)")
            else:
                ctx.log.debug("[revoc] unknown revocation but policy fail_open: allowing")

    def _block_flow(self, flow: http.HTTPFlow, reason: str):
        ctx.log.warn(f"[revoc] blocking flow to {getattr(flow.server_conn, 'address', '(unknown)')}: {reason}")
        try:
            flow.response = http.Response.make(
                502,
                b"Upstream server certificate revoked or invalid (mitmproxy blocked connection)\n",
                {"Content-Type": "text/plain"},
            )
        except Exception:
            try:
                if flow.server_conn:
                    flow.server_conn.close()
            except Exception:
                pass
            try:
                if flow.client_conn:
                    flow.client_conn.close()
            except Exception:
                pass


addons = [RevocationCheckerV3()]
